---
title:  "'다이나믹 프로그래밍(DP)'이란"

categories:
  - Algorithm
tags:
  - DP
---

이 글은 '다이나믹 프로그래밍(DP)'에 대해서 필자가 공부한 내용을 보기 편하게 정리한 것이다.  
  
작년에 withcs를 풀며 다이나믹 프로그래밍에 관한 문제들을 자주 접하게 되었고, 그 때부터 구글링을 통해 모아왔던 지식들은 너무 산발적이고 휘발적이라고 생각하여 정리하게 되었다.  
  
## 1. 다이나믹 프로그래밍(DP)이란? 
다이나믹 프로그래밍(Dynamic Programming)은 '동적 계획법'이라고도 불리는데, 그 이름만 보아서는 도저히 그 의미를 유추할 수 없어 보인다. 그래서 가장 보편적인 피보나치 수열을 예시로 들어 설명해보겠다.  

[백준 2747번 피보나치 수](https://www.acmicpc.net/problem/2747)  
피보나치 수를 구하는 문제를 재귀함수와 동적 계획법을 이용하여서 풀어보겠다.
```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int fib(int N);

int main(void) {
	int N;
	scanf("%d", &N);
	printf("%d", fib(N));
	return 0;
}
```
이렇게 기본적인 원형을 작성한뒤에, fib()을 작성해보겠다.  

우선 재귀함수를 이용하여 fib()을 작성하였다.
```c
int fib(int N) {
	if (N == 0)	return 0;
	if (N == 1)	return 1;

	return fib(N - 1) + fib(N - 2);
}
```
다음은 동적 계획법을 이용하여 fib()을 작성하였다.
```c
int fib(int N) {
	int dp[46];
	dp[0] = 0;
	dp[1] = 1;

	for (int i = 2; i < N + 1; i++) {
		dp[i] = dp[i - 1] + dp[i - 2];
	}
	return dp[N];
}
```
사실 이렇게만 보면 다이나믹 프로그래밍이 왜 필요한지 모를 것 같아 보인다. 하지만 재귀함수를 이용한 코드에서는 상당한 계산의 중복이 발생한다. 예를 들어, fib(5)를 구하기 위해서는 fib(4)와 fib(3)을 구해야하고, fib(4)에서는 다시 fib(3)과 fib(2)를 계산한다. 벌써 이 과정에서 fib(3)을 중복하여 계산하는 낭비가 발생한다.  
  
반면 동적 계획법을 이용한 코드는 dp[]라는 배열에 값을 저장하여서 다시 불러오는 형태이기 때문에 계산의 중복이 일어나지 않는다. 이를 메모이제이션(memoization)이라고 한다.
