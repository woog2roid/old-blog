---
title:  "'다이나믹 프로그래밍(DP)'이란 - 1, 이론적 배경"

categories:
  - Algorithm
tags:
  - DP, Book_Reivew
---

이 글은 '다이나믹 프로그래밍(DP)'에 대해서 필자가 공부한 내용을 보기 편하게 정리한 것이다.  

알고리즘에 관심을 갖게 될 무렵 한빛 미디어의 __"빠르고 우아한 상향식 문제 풀이법, 다이내믹 프로그래밍 완전 정복"__ 이라는 책을 읽게 되었다.

이 책은, 다이나믹 프로그래밍을 단계별로 풀이하며, 그 전까지는 DP를 스스로 풀지 못하고 답을 보고 이해하던 나를,  능동적으로 풀 수 있도록 많은 도움을 주었기에 책의 내용을 정리하였다. 

물론 필자의 입장에서 필요하다고 생각되는 부분을 위주로 정리를 하였기 때문에, 어느정도 책의 내용을 숙지하고 있는 부분은 생략이 되어있기도 하다.
  
## 1. 재귀 접근 방법이란? 

우선 DP에 본격적으로 접근을 하기 이전에 책에서는 재귀(recursion)에 대해 먼저 설명하고 지나간다. 필자도 처음에는 왜 재귀를 설명하고 넘어가는 지 잘 이애하지 못하였지만, 후에 __*DP의 점화식을 세우는 과정*__ 이나 __*DP의 이론적인 면을 이해하는 데*__ 충분한 도움이 되기 때문에 이해하고 넘어갈 필요가 있다. 물론, 필자의 수준에 맞춰 재귀에 대해서는 크게 다루지 않을 것이다.

### 재귀 접근 방법에서는,
- *재귀에는 항상 종료조건이 있어야 한다.*
- *재귀 함수는 전체 작업의 일부만 수행하고 나머지는 재귀호출에 위임한다.*

프로그래밍을 하다 보면 가끔 재귀를 이상하게 작성하는 경우가 많은데, 보통 저 두 조건을 못 지키는 경우가 많다. 종료조건이 명확하지 않거나, 다음 재귀 호출에서 해야할 일을 해버린다거나, 인수가 제대로 적혀있지 않다거나 등등 ...... 나에게 하는 말이기도 하다. 

- 기본적인 문제로는, 팩토리얼 계산이나 제곱계산이 있지만 psss...
- 자료구조에서 나오는 트리의 순회 구현에 이용
- 혹시 나중에 다시 읽어볼 때를 위해, 하노이탑 (https://www.acmicpc.net/problem/1914)

### 재귀 접근 방법의 메모리 상태
- 재귀 호출을 이용하면 메모리와 실행시간 양 측면에서 비용이 증가한다.

## 2. 메모이제이션

### *재귀접근 방식이 가지는 특징*
- *최적의 하위 구조를 가짐* --> n을 푸는 방법과 n-1을 푸는 방법이 동릴하다는 의미
- *하위 문제의 반복 계산* --> 꼭 그렇다는 것은 아니고 복잡한 재귀 문제에서는 그러하다라는 것

__*이는 DP를 조금이라도 공부해본 사람이라면 많이 들어봤을 용어이다. DP의 조건으로 전공책에서 overlapping subproblems, optimal substructure를 소개하는 것을 봤을 것이다. 이는 DP가 재귀를 최적화하는 모양새를 띄기 떄문이다.*__

재귀 접근 방법에서는 중복된 하위의 계산을 반복해서 실행하게 된다. 이는, 피보나치 문제, 팩토리얼 계산을 통해서 쉽게 몸으로 이해할 수 있다. 이를 해결하기 위해, 캐시를 만들어줄 수 있다. 사실 메모이제이션과 관련해서는 충분히 알고 있는 내용이기 때문에 생략하도록 하겠다. 혹여라도 이 블로그를 참고하는 누군가를 위해 위키링크를 첨부하겠다. 저 링크면 아마 메모이제이션의 내용은 충분하게 이해를 할 것이다.

[wiki/메모이제이션](https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98)

### __이 파트에서는 메모이제이션이 overlapping subproblems(하위 문제의 반복 계산)을 해결하기 위한 방법임을 이해하면 된다.__

## 3. Top-Down vs Bottom-Up?

이 책에서는, Top-Down보다는 Bottom-Up에 맞추어서 설명을 하고 있다. 그 이유로는, 재귀방식 자체의 문제 때문인데, 스택에 메모리를 계속해서 쌓아두는 것과 모르는 값을 호출해서 역으로 내려가기 때문이다.

책에서는 직접 재귀와 Top-Bottom DP, Bottom-Up DP를 비교하는 코드를 github에 올렸다.

[깃허브 링크](https://github.com/crapas/dp)

확인해보면 상향식 방법이 하향식 방법에 비해 빠른 것을 확인해 볼 수 있다.

### 하지만, 항상 상향식 방법이 하향식 방법에 비해 빠른 성능을 자랑하는 것은 아닌데, 상향식 DP가 적절한 풀이법이 아닌경우는, __굳이 다 계산하지 않아도 되는 경우이다.__

상향식 DP는 아래에서 부터 채워 올라가기 때문에, 캐시의 모든 부분으 채워 올라간다는 단점이 존재한다. 하지만, 문제에 따라 굳이 모든 경우가 필요하지 않은 경우가 존재한다. 그 예로 바로 조합(combination)이다. 

조합론에서의 조합(combination)연산은 파스칼의 삼각형을 통해 표현되기도 하는데, 이를 DP로 구현한다고 하는 경우를 생각해보자.

C(5,4)를 구하기 위해서 Top-Down방식에서는 C(5,4) = C(4,3) + C(4,4) / C(4,3) = ...... 과 같은 방식으로 필요한 값만을 계산해 나갈 것이다. 하지만, Bottom-Up 방식에서는 그저 모든 index를 채워나가며 올라가기 때문에 성능이 떨어질 수 밖에 없다.

## 간단하게 정리하자면,
- __DP는 재귀를 최적화 한다.__
  - overlapping subproblem을 해결하기 위해서 memoization 기법이 사용된다.
  - Top-down 방식과 Bottom-Up 방식중에는 대게는 Bottom-Up 방식이 성능이 더 뛰어나다 
    - (이는 재귀 자체의 메모리 낭비나 무의미한 호출 등으로 인한 것이다.)
  - 드물게 Top-Down 방식이 더 뛰어난 경우가 있는데, 이는 '필요한 것만 연산'하는 그 특성 때문이다. 
    - (파스칼 삼각형에서 특정 index 구하기 같은 경우가 있을 수 있다.)